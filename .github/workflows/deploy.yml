name: Deploy

on:
  workflow_run:
    workflows: ["Build and Push"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  REGISTRY: docker.io
  IMAGE_NAME: sarafrika-camp-ussd

jobs:
  deploy:
    runs-on: ubuntu-latest
    name: Deploy to Server
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install sshpass
      run: sudo apt-get update && sudo apt-get install -y sshpass
        
    - name: Add server to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
        
    - name: Create deployment directory
      run: |
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p ~/products/camp-ussd"
        
    - name: Copy deployment files
      run: |
        # Remove existing docker-compose.yml to ensure fresh deployment
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} "rm -f ~/products/camp-ussd/docker-compose.yml"
        # Copy fresh deployment files
        sshpass -p '${{ secrets.SSH_PASSWORD }}' scp docker-compose.yml .env.example ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }}:~/products/camp-ussd/
        
    - name: Setup environment configuration
      run: |
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ~/products/camp-ussd
          
          # Create .env file from template if it doesn't exist
          if [ ! -f .env ]; then
            echo "üìã Creating .env file from .env.example template..."
            cp .env.example .env
            echo "‚ö†Ô∏è  .env file created from template. Please configure the required variables."
          else
            echo "üìã .env file already exists. Checking for missing properties..."
            
            # Add missing properties from .env.example to existing .env
            while IFS= read -r line; do
              if [[ "$line" =~ ^[A-Z_]+=.* ]]; then
                var_name=$(echo "$line" | cut -d'=' -f1)
                if ! grep -q "^${var_name}=" .env; then
                  echo "‚ûï Adding missing property: $var_name"
                  echo "$line" >> .env
                fi
              fi
            done < .env.example
          fi
        EOF
        
    - name: Validate environment configuration
      run: |
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ~/products/camp-ussd
          
          missing_vars=()
          placeholder_vars=()
          
          # Check each variable defined in .env.example
          while IFS= read -r line; do
            if [[ "$line" =~ ^[A-Z_]+=.* ]]; then
              var_name=$(echo "$line" | cut -d'=' -f1)
              
              if ! grep -q "^${var_name}=" .env; then
                missing_vars+=("$var_name")
              else
                value=$(grep "^${var_name}=" .env | cut -d'=' -f2-)
                # Check if value contains placeholder text or is empty
                if [[ -z "$value" ]] || [[ "$value" =~ ^(your_|your-) ]]; then
                  placeholder_vars+=("$var_name")
                fi
              fi
            fi
          done < .env.example
          
          # Report missing variables
          if [ ${#missing_vars[@]} -gt 0 ]; then
            echo "‚ùå Missing required environment variables:"
            printf "   - %s\n" "${missing_vars[@]}"
          fi
          
          # Report placeholder values
          if [ ${#placeholder_vars[@]} -gt 0 ]; then
            echo "‚ö†Ô∏è  Environment variables with placeholder values (need configuration):"
            printf "   - %s\n" "${placeholder_vars[@]}"
          fi
          
          # Fail if there are missing or unconfigured variables
          if [ ${#missing_vars[@]} -gt 0 ] || [ ${#placeholder_vars[@]} -gt 0 ]; then
            echo ""
            echo "üí° Please update the .env file on the server at: ~/products/camp-ussd/.env"
            echo "   Use the .env.example as a reference for required configuration."
            exit 1
          else
            echo "‚úÖ All required environment variables are properly configured"
          fi
        EOF
        
    - name: Deploy application
      run: |
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ~/products/camp-ussd
          
          # Pull latest image
          docker pull ${{ env.REGISTRY }}/sarafrika/${{ env.IMAGE_NAME }}:latest
          
          # Stop existing containers
          docker-compose down || true
          
          # Start services
          docker-compose up -d
          
          # Clean up old images
          docker image prune -f
        EOF
        
    - name: Verify deployment
      run: |
        echo "üîç Starting deployment verification..."
        
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
          cd ~/products/camp-ussd
          
          # Check if containers are running
          max_attempts=12
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts - Checking container status..."
            
            # Check if the main application container is running
            if docker-compose ps app | grep -q "Up"; then
              echo "‚úÖ Application container is running"
              
              # Additional check: ensure container is healthy (not just running)
              container_id=$(docker-compose ps -q app)
              if [ -n "$container_id" ]; then
                container_status=$(docker inspect --format='{{.State.Health.Status}}' $container_id 2>/dev/null || echo "unknown")
                if [ "$container_status" = "healthy" ] || [ "$container_status" = "unknown" ]; then
                  echo "‚úÖ Container health status: $container_status"
                  echo "üöÄ Deployment verification successful"
                  exit 0
                else
                  echo "‚ö†Ô∏è Container health status: $container_status"
                fi
              else
                echo "‚úÖ Container is running (health check not configured)"
                exit 0
              fi
            else
              echo "‚ùå Application container is not running"
              docker-compose ps
            fi
            
            if [ $attempt -lt $max_attempts ]; then
              echo "Waiting 10s before next attempt..."
              sleep 10
            fi
            
            attempt=$((attempt + 1))
          done
          
          echo "‚ùå Deployment verification failed after $max_attempts attempts"
          echo "Final container status:"
          docker-compose ps
          docker-compose logs app --tail=20
          exit 1
        EOF
        
    - name: Fallback health check
      if: failure()
      run: |
        echo "Checking local container health as fallback..."
        sshpass -p '${{ secrets.SSH_PASSWORD }}' ssh ${{ secrets.SSH_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
        local_response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:40000/q/health/live || echo "000")
        echo "Local container health check: HTTP $local_response"
        
        if [ "$local_response" -eq 200 ]; then
          echo "üîß Container is healthy but may have connectivity/proxy issues"
        else
          echo "üí• Container is also unhealthy locally"
        fi
        EOF
        
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "üöÄ Deployment to ${{ github.event.inputs.environment || 'production' }} completed successfully!"
        else
          echo "üí• Deployment to ${{ github.event.inputs.environment || 'production' }} failed!"
        fi